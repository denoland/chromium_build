# Copyright 2021 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/rust.gni")
import("//build/rust/rust_cxx.gni")
import("//build/rust/rust_unit_test.gni")

# Creates a Rust target (rlib, executable, proc macro etc.) with
# ability to understand some handy variables such as "edition" and
# "features" and also to build any associated unit tests.
#
# Normally, you should not use this directly. Use either
#   cargo_crate.gni - for 3p crates only
#   rust_static_library.gni - for 1p Rust code
# You might, rarely, want to use this for a Rust executable.
#
# Because the common use of this is rust_static_library, all the documentation
# for the supported options is given in rust_static_library.gni. Please refer
# over there.
#
# If you're using rust_chrome_target directly, you will also need to specify:
#   target_type
#     executable, rust_library etc. per GN norms
#
#   create_cpp_groups (bool)
#     Whether both C++ and Rust may link against this. If so, groups
#     are created for downstream targets to link against in both languages
#     (again, see rust_static_library for docs). Only works for rust_library
#     types.
#
# There is one area where this differs from `rust_static_library`: configs.
# Here, you must specify `executable_configs` or `library_configs`
# depending on the type of thing you're generating. This is so that
# different defaults can be provided.

template("rust_target") {
  _target_name = target_name
  _crate_name = _target_name
  if (defined(invoker.crate_name)) {
    _crate_name = invoker.crate_name
  }
  if (defined(invoker.crate_root)) {
    _crate_root = invoker.crate_root
  } else if (invoker.target_type == "executable") {
    _crate_root = "src/main.rs"
  } else {
    _crate_root = "src/lib.rs"
  }

  if (defined(invoker.output_dir) && invoker.output_dir != "") {
    _out_dir = invoker.output_dir
  } else {
    _out_dir = target_out_dir
  }

  _rustflags = []
  if (defined(invoker.rustflags)) {
    _rustflags += invoker.rustflags
  }
  if (defined(invoker.features)) {
    foreach(i, invoker.features) {
      _rustflags += [ "--cfg=feature=\"${i}\"" ]
    }
  }
  _edition = "2021"
  if (defined(invoker.edition)) {
    _edition = invoker.edition
  }
  _configs = [ string_join("",
                           [
                             "//build/rust:edition_",
                             _edition,
                           ]) ]
  if (invoker.target_type == "executable") {
    if (defined(invoker.executable_configs)) {
      _configs += invoker.executable_configs
    }
  } else {
    if (defined(invoker.library_configs)) {
      _configs += invoker.library_configs
    }
  }
  _forward_to_host_toolchain = false
  if (invoker.target_type == "rust_proc_macro") {
    # TODO(crbug.com/gn/104): GN rust_proc_macro targets are missing this
    # command line flag, for the proc_macro crate which is provided by rustc for
    # compiling proc-macros.
    _rustflags += [
      "--extern",
      "proc_macro",
    ]

    _forward_to_host_toolchain = true
    _forward_to_target_name = "${target_name}_proc_macro"
  }

  _deps_for_rust_targets = []
  if (defined(invoker.mutually_dependent_target)) {
    _deps_for_rust_targets += [ invoker.mutually_dependent_target ]
  }
  _deps = []
  if (defined(invoker.deps)) {
    _deps += invoker.deps
  }
  _public_deps = []
  if (defined(invoker.public_deps)) {
    _public_deps += invoker.public_deps
  }

  _build_unit_tests = build_rust_unit_tests
  if (defined(invoker.skip_unit_tests) && invoker.skip_unit_tests == true) {
    _build_unit_tests = false
  }
  if (defined(invoker.cxx_bindings)) {
    _deps_for_rust_targets += [
      ":${_target_name}_cxx",
      "//build/rust:cxx_rustdeps",
    ]
    _cxx_bindings = invoker.cxx_bindings
  }

  # TODO(danakj): This could be a hash generated from the input crate, such as
  # from its path, in which case the BUILD.gn would not need to specify
  # anything. But GN doesn't give us a hash function to make that easy.
  _metadata = "0"
  if (defined(invoker.epoch)) {
    _metadata = invoker.epoch
  }

  # We require that all source files are listed, even though this is
  # not a requirement for rustc. The reason is to ensure that tools
  # such as `gn deps` give the correct answer, and thus we trigger
  # the right test suites etc. on code change.
  # TODO(crbug.com/1256930) - verify this is correct
  assert(defined(invoker.sources), "sources must be listed")

  _create_cpp_groups = false
  if (defined(invoker.create_cpp_groups)) {
    _create_cpp_groups = invoker.create_cpp_groups
  }

  # If this code may be linked by both C++ and Rust, make differing
  # groups of deps for each of them, because unfortunately there are
  # differences in what they need to link against.
  main_target_suffix = ""
  if (_create_cpp_groups) {
    assert(invoker.target_type == "rust_library" ||
           invoker.target_type == "shared_library")
    main_target_suffix = "__rlib"

    # Downstream Rust targets should include this in their deps.
    group(target_name) {
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
      deps = [ ":${_target_name}${main_target_suffix}" ]
      deps += _deps_for_rust_targets
    }

    # Downstream C++ targets should include this in their deps.
    group("${_target_name}_cpp_bindings") {
      deps = [ ":${_target_name}${main_target_suffix}" ]
      if (invoker.target_type == "rust_library") {
        deps += [
          # For a rust_library, any C++ code depending on this target should
          # also depend on the Rust standard library to ensure it's linked into
          # the final binary by the C++ linker. This isn't needed for a
          # shared_library, as rustc will link the stdlib into it already.
          "//build/rust/std",
        ]
      }
      if (defined(invoker.mutually_dependent_target)) {
        forward_variables_from(invoker,
                               TESTONLY_AND_VISIBILITY,
                               [ "visibility" ])
        visibility = [ invoker.mutually_dependent_target ]
      } else {
        forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
      }
      if (defined(_cxx_bindings)) {
        public_deps = [ ":${_target_name}_cxx" ]
      }
    }
  } else {
    # This is a plain simple single Rust target.
    assert(!defined(invoker.mutually_dependent_target))
    assert(_deps_for_rust_targets == [])
    assert(main_target_suffix == "")
  }

  _generate_target = true
  if (_forward_to_host_toolchain) {
    if (current_toolchain != host_toolchain) {
      # Redirect to the host toolchain.
      group(target_name) {
        forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
        public_deps = [ ":${_forward_to_target_name}($host_toolchain)" ]
      }

      not_needed(invoker, "*")
      not_needed([
                   "_deps",
                   "_public_deps",
                   "proc_macro_target",
                 ])
      _generate_target = false
    } else {
      # We're in the host toolchain, so just generate an alias.
      group(target_name) {
        forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
        public_deps = [ ":${_forward_to_target_name}" ]
      }
    }

    # Since we're forwarding through a group which uses `target_name`, we rename
    # the actual target to what the group points at.
    target_name = _forward_to_target_name
  }

  if (_generate_target) {
    target(invoker.target_type, "${target_name}${main_target_suffix}") {
      crate_name = _crate_name
      crate_root = _crate_root
      configs = []
      configs = _configs
      deps = _deps
      public_deps = _public_deps
      if (defined(_cxx_bindings)) {
        deps += [ "//build/rust:cxx_rustdeps" ]
      }
      rustflags = _rustflags
      rustflags += [ string_join("",
                                 [
                                   "-Cmetadata=",
                                   _metadata,
                                 ]) ]
      forward_variables_from(invoker,
                             "*",
                             [
                               "configs",
                               "deps",
                               "features",
                               "public_deps",
                               "rustflags",
                               "rustenv",
                               "output_dir",
                               "unit_test_target",
                               "visibility",
                             ])
      rustenv = [ "OUT_DIR=" + rebase_path(_out_dir) ]
      if (defined(invoker.rustenv)) {
        rustenv += invoker.rustenv
      }

      # The Rust tool() declarations, like C++ ones, use the output_name and
      # output_dir, so that GN targets can override these if needed. Here we
      # give them their default values, or allow them to be overridden.
      output_dir = _out_dir
      if (!defined(output_name) || output_name == "") {
        output_name = crate_name
      }
      if (_create_cpp_groups) {
        visibility = [
          ":${_target_name}",
          ":${_target_name}_cpp_bindings",
        ]
      } else {
        forward_variables_from(invoker, [ "visibility" ])
      }
    }

    if (defined(_cxx_bindings)) {
      rust_cxx("${_target_name}_cxx") {
        inputs = _cxx_bindings
        native_header_deps = _deps + _public_deps
        if (is_component_build) {
          # In a component_build the cxx bindings may be linked into a shared
          # library at any point up the dependency tree, so always export.
          export_symbols = true
        } else if (invoker.target_type == "shared_library") {
          export_symbols = true
        } else {
          export_symbols = false
        }
      }
    }
  } else {
    not_needed([
                 "_metadata",
                 "_crate_root",
                 "_crate_name",
                 "_out_dir",
               ])
  }

  if (_generate_target && _build_unit_tests) {
    _unit_test_target = "${_target_name}_unittests"
    if (defined(invoker.unit_test_target)) {
      _unit_test_target = invoker.unit_test_target
    }

    rust_unit_test(_unit_test_target) {
      forward_variables_from(invoker, [ "sources" ])
      crate_root = _crate_root
      rustflags = _rustflags
      output_dir = _out_dir
      deps = _deps + _public_deps
      if (defined(invoker.test_deps)) {
        deps += invoker.test_deps
      }
      if (defined(invoker.executable_configs)) {
        configs = []
        configs = invoker.executable_configs
      }
      deps += _deps_for_rust_targets
    }
  } else {
    not_needed([
                 "_test_deps",
                 "_build_unit_tests",
               ])
    not_needed(invoker, [ "test_deps" ])
  }
}

set_defaults("rust_target") {
  executable_configs = default_executable_configs
  library_configs = default_compiler_configs
}
